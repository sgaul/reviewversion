---
title       : Review version of top indicators
subtitle    : Hartford regional indicators
author      : 
job         : Community Indicators Project
framework   : io2012        # {io2012, html5slides, shower, dzslides, minimal ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      # 
ext_widgets : {rCharts: ["libraries/nvd3"]} 
mode        : selfcontained # {standalone, draft}

--- &twocol
## Outline of indicators

*** =left
Background on the region
* Population / diversity
* Commuting patterns
* School enrollment
* Income levels and poverty rates

Education
* 3rd grade reading
* High school graduation rate

*** =right
Jobs
* Educational attainment
* Job growth

Quality of life / civic health
* Home ownership
* Affordable housing
* Crime rate
* Voter turnout

---
## Key themes

1. 'We are a region'
2. Concentration of poverty in Hartford
3. Suburbanization of poverty
4. Aging population and workforce
5. Globally connected region
6. Achievement gap and talent pipeline
7. Creating opportunity in communities throughout the region

---

## Defining the region: Hartford + surrounding towns

CRCOG region. Based on characteristics of each town, using UConn categories from [5 CTs report](http://ctsdc.uconn.edu/projections/5cts.html), with slight updates. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 14}
library(ggplot2)
library(reshape)
library(scales)
library(acs)
library(maps)
library(maptools)
towns <- read.csv("../regionalreport/data/hartford-towns.csv")

towns$Towngroup <- factor(towns$Towngroup, levels = c("Hartford",
                                                      "Urban periphery",
                                                      "Suburban / rural"))

CTTowns <- readShapeSpatial(fn="../townshp/wgs84/townct_37800_0000_2010_s100_census_1_shp_wgs84")

#Fortify and order the CTTowns to allow ggmap to use that
CTTowns <- fortify(CTTowns, region = "NAME10")

#Merge map and data
choropleth=merge(CTTowns, towns, by.x = "id", by.y="Town")
choropleth=choropleth[order(choropleth$order), ]

#Make the map
ggplot(data = choropleth, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = Towngroup)) + 
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = NULL, y = NULL) + 
  coord_equal() +
  geom_polygon(data = CTTowns, colour = "grey", alpha = 0.5, fill = NA) +
  scale_fill_brewer(palette = "Blues", name = "Types of towns") +
  theme_minimal(base_size = 16)

write.csv(towns,"../rawdata/towns.csv", row.names = FALSE)
```

---
## Low population growth

Low population growth overall; losing population in center city, slow growth outside, most rapid in outer suburbs. Region struggles to attract new residents. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 12}
library(ggplot2)
library(scales)
library(reshape)

gh <- read.csv("../regionalreport/data/greaterhartford.csv")
towns <- read.csv("../regionalreport/data/hartford-towns.csv")
gh$poppoverty <- round((gh$poppovertyrate / 100) * gh$population,0)
gh_test <- ddply(merge(gh,towns,by.x = "city", by.y = "Town"),
                 .(period,Towngroup), summarise, 
                 sumpop = sum(population),
                 sumpoor = sum(poppoverty))

ggplot() + 
  geom_line(data = subset(gh_test, period >= 1900 & period <= 2010), size = 1, 
            aes(x = period, y = sumpop, group = Towngroup, colour = Towngroup)) + 
  geom_line(data = subset(gh_test, period >= 2010), linetype = 'dotted', size = 1,
            aes(x = period, y = sumpop, group = Towngroup, colour = Towngroup)) + 
  theme_minimal(base_size = 16) + 
  scale_y_continuous(labels = comma, lim = c(0,500000)) +  
  labs(x = "Year", y = "Population")

write.csv(subset(gh_test, period >= 1900),"../rawdata/population.csv", row.names = FALSE)
```

--- 
## Suburbanization of poverty

New poverty occurring in suburbs, new challenges towns can't ignore. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 13}
gh <- merge(gh,towns, by.x = "city", by.y = "Town")

gh_sum <- ddply(gh,.(Towngroup, period), summarise, 
                population = sum(population), 
                population.under.poverty = sum(poppoverty),
                median = median(medianfamilyincome, na.rm = T),
                min = min(medianfamilyincome, na.rm = T),
                max = max(medianfamilyincome, na.rm = T))

ggplot(aes(y = population.under.poverty, 
           x = period), data = subset(gh_sum,period >= 1970 & period <= 2012)) + 
  geom_line(aes(group = Towngroup, colour = Towngroup), size = 1) + 
  scale_y_continuous(labels = comma, limits = c(0,50000)) + 
  labs(x = "Year", y = 'Population living under poverty line') +
  theme_minimal(base_size = 16)

write.csv(subset(gh_sum,period >= 1970),"../rawdata/poverty.csv", row.names = FALSE)
```

---
## Aging population

Suburbs are aging quickly with no good prospects for replacing with younger generation, based on current projections. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 12}
projections <- read.csv('../reviewversion/sdc-projections.csv')
towns <- read.csv("../regionalreport/data/hartford-towns.csv")
projections <- subset(projections, projections$TOWN %in% levels(towns$Town))
projections$TOWN <- factor(projections$TOWN)
#projections$YEAR <- paste("20",projections$YEAR, sep = "")

projections <- merge(projections, towns, by.x = "TOWN", by.y = "Town")

levels(projections$AGE) <- list(
  "55 years and over" = c("8084","6064","7579","5559","90OV","7074","8589","6569"),
  "25 to 54 years" = c("4549","2529","4044","3539","5054","3034"),
  "16 to 24 years" = c("2024","1519"),
  "0 to 16 years" = c("0004","0509","1014","4","509"))

#projections$TYPE = ifelse(projections$TOWN == "Hartford","Hartford","Other region")

#aging <- ddply(projections, .(YEAR, AGE, GENDER, TYPE), summarise, sum = sum(value))
#aging <- cast(aging, TYPE + YEAR + AGE ~ GENDER)

#levels(aging$AGE) <- rev(levels(aging$AGE))

projections$AGE <- factor(projections$AGE, levels = c("0 to 16 years",
                                                      "16 to 24 years",
                                                      "25 to 54 years",
                                                      "55 years and over"))

projections$Towngroup <- factor(projections$Towngroup, levels = c("Hartford",
                                                                  "Urban periphery",
                                                                  "Suburban / rural"))

ggplot() + 
  geom_line(data = ddply(subset(projections, YEAR >= 2010), 
                         .(YEAR, AGE, Towngroup), summarise, value = sum(value)), 
            aes(x = YEAR, y = value, group = Towngroup, colour = Towngroup), 
            size = 1, linetype = 'dotted') +
  geom_line(data = ddply(subset(projections, YEAR <= 2010), 
                         .(YEAR, AGE, Towngroup), summarise, value = sum(value)), 
            aes(x = YEAR, y = value, group = Towngroup, colour = Towngroup), 
            size = 1) +
  facet_wrap(~ AGE, ncol = 4) +
  scale_x_continuous(breaks = c(2000,2010,2020)) + 
  scale_fill_brewer(name = "Age") +
  scale_y_continuous(labels = comma) + 
  labs(y = "Population", x = "Year") +
  theme_minimal(base_size = 16)

write.csv(ddply(projections, .(YEAR, AGE, Towngroup), summarise, value = sum(value)),
          "../rawdata/aging.csv", row.names = F)
```

--- 
## School enrollment declining

Aging population reflected in overall decline in school enrollment. Local schools impacted by demographics and through increase in magnet / private enrollment. Leading to large number of neighborhood school closures/consolidations.

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 14}
enroll <- read.csv("../regionalreport/data/all-schools.csv", stringsAsFactors=FALSE)

#Filter out the towns that are not in the region and clear out the factors
enroll <- subset(enroll, enroll$Resident.Town %in% levels(towns$Town))
enroll$Resident.Town <- factor(enroll$Resident.Town)

charters <- data.frame(charters = c("The Bridge Academy District",
                            "Trailblazers Academy District",
                            "Side By Side Community School District",
                            "Park City Prep Charter School",
                            "Odyssey Community School District",
                            "New Beginnings Inc., Family Academy District",
                            "Jumoke Academy District",
                            "Highville Charter School District",  
                            "Highville Mustard Seed Charter School District",       
                            "Integrated Day Charter School District",        
                            "Interdistrict School for Arts and Comm District",
                            "Explorations District",
                            "Elm City College Preparatory School",
                            "Common Ground High School District",
                            "Charter School for Young Children on Asylum Hill",
                            "Bridgeport Achievement First",
                            "Achievement First Hartford Academy Inc.",                
                            "Amistad Academy District"))

#Make the charters into their own category
enroll$School.Type[enroll$Sent.to.District %in% levels(charters[,])] <- 'Public charter'

#Replace the less frequent school types with 'Other'
enroll$School.Type <- gsub("Homebound","Other",enroll$School.Type)
enroll$School.Type <- gsub("Voag","Other",enroll$School.Type)
enroll$School.Type <- gsub("Interdistrict Cooperative Agreement","Other",enroll$School.Type)
enroll$School.Type <- gsub("Designated High School","Other",enroll$School.Type)
enroll$School.Type <- gsub("Nonpublic","Private",enroll$School.Type)

#Melt the dataset to get it into a more normalized format for plotting
enroll <- melt(enroll, 
               measure.vars = c("PK","K","G1","G2","G3","G4","G5","G6","G7","G8","G9","G10","G11","G12","Total"),
               id.vars = c("Resident.Town.ID","District.ID","Resident.Town","Sent.to.District","School.Year","School.Type"))

#Get rid of the sent to districts since there are multiple districts for each
enroll <- aggregate(enroll$value,
                    list(Resident.Town = enroll$Resident.Town, 
                         School.Year = enroll$School.Year, 
                         School.Type = enroll$School.Type, 
                         variable = enroll$variable), 
                    sum)

enroll$School.Type <- factor(enroll$School.Type)

levels(enroll$School.Type) <- list(
  "Public" = c("Public"),
  "Private" = c("Private"),
  "Magnet/Charter/Choice" = c("Public charter","Magnet School","Open Choice"),
  "Other" = c("Other"))

#Sort the school types for the display
enroll$School.Type <- factor(enroll$School.Type, levels = c("Public",
                                                            "Private",
                                                            "Magnet/Charter/Choice",
                                                            "Other"))

ggplot(data = ddply(merge(subset(enroll, variable == "Total" & 
                                   School.Type != "Other"),
                          towns, 
                          by.x = "Resident.Town",by.y = "Town"),
      .(Towngroup, School.Type, School.Year),summarise, x = sum(x)),
       aes(x = School.Year, y = x, group = School.Type, fill = School.Type)) +
  geom_line(aes(group = School.Type, colour = School.Type)) +
  geom_point(aes(group = School.Type, colour = School.Type, shape = School.Type)) +
  scale_y_continuous(labels = comma) +
  scale_x_discrete(breaks = c("2006-07","2008-09","2010-11")) +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 16) +
  facet_wrap(~ Towngroup, ncol = 3)

write.csv(ddply(merge(subset(enroll, variable == "Total"), towns, 
                          by.x = "Resident.Town",by.y = "Town"),
      .(Towngroup, School.Type, School.Year),summarise, x = sum(x)), 
          "../rawdata/enrollment.csv", row.names = FALSE)

```

--- 
## Linguistic diversity

More diversity in changing population (tie back to 1st chart); which suburbs will 'globalize'? Where will new population in our region come from and what impact will this have?

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 12}
languages <- read.csv('../reviewversion/Languages-all.csv', na.strings = c("**","-"))
districts <- read.csv("../regionalreport/data/hartford-districts.csv")
languages <- merge(languages, districts, by.x = "District.Name", by.y = "district")

languages_agg <- merge(ddply(languages, .(District.Name), summarise,all.lang = length(unique(Languages)),all.students = sum(Number.of.Students.with.Non.English.Home.Language, na.rm = TRUE)),
                       ddply(subset(languages, Number.of.ELL.Students > 0),
                             .(District.Name), summarise,ell.lang = length(unique(Languages)),ell.students = sum(Number.of.ELL.Students, na.rm = TRUE)),
                       by = "District.Name", 
                       all = TRUE)

#All linguistic diversity
languages_agg$District.Name <- reorder(languages_agg$District.Name,
                                       languages_agg$all.lang)

ggplot(data = languages_agg) + 
  geom_point(aes(x = all.lang, y = District.Name)) + 
  labs(x = 'Number of languages spoken, all students', y = NULL) + 
  scale_x_continuous(labels = comma) + 
  theme_minimal(base_size = 16)

write.csv(languages,"../rawdata/languages.csv", row.names = F)
```

--- 
## Everyone commutes, mostly to Hartford

Large segments of regions workers commute to Hartford and some other communities with high concentration of high-skill jobs. Typical of capital cities.

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 13}
inflow <- read.csv('../reviewversion/inflow-outflow.csv')

#inflow$x = inflow$Commute.in...Work.and.live + inflow$Commute.out...Work.and.live

inflow$commute.to.pop = 
  inflow$Employed.in.the.Selection.Area.but.Living.Outside / 
  inflow$Living.in.the.Selection.Area

#ggplot(data = subset(inflow, Type == "City"), 
#       aes(x = commute.to.pop, y = Geography)) + 
#  geom_point()

ggplot(data = subset(inflow, Type != "CBSA" & 
                       Employed.in.the.Selection.Area < 250000), 
       aes(x = Commute.in...Work.and.live, 
           y = Commute.out...Work.and.live)) +
#  geom_point(aes(size = Employed.in.the.Selection.Area)) + 
  geom_text(aes(label = Geography, size = Employed.in.the.Selection.Area, 
                colour= Type)) + 
  scale_size(name = "Number\nemployed (2011)", labels = comma) + 
  labs(x = "# people commuting into city / # people living and working in city", 
       y = "# people commuting out of city / # people living and working in city") + 
  theme_minimal()


otm <- read.csv("../regionalreport/data/otmdata.csv")
otm$Destination <- gsub(pattern = " (town|borough) \\(([A-z]|[^A-z])+,[ \t\n\r\f\v][A-Z]+\\)", 
                        replacement = "", otm$Destination)
otm$Starting.point <- gsub(pattern = " (town|borough) \\(([A-z]|[^A-z])+,[ \t\n\r\f\v][A-Z]+\\)", 
                           replacement = "", otm$Starting.point)

#Add the ratio of workers for each starting point town
sum <- tapply(otm$Number, otm$Starting.point, sum)
otm$ratio <- otm$Number / sum[otm$Starting.point]

write.csv(subset(otm, ratio > 0.05 & !(Destination == "All Other Locations")), 
          "../rawdata/commuting.csv", row.names = FALSE)
```


--- 
## Demand for a skilled workforce

Region continues to have highly skilled workforce, but skills are not equitably distributed among all resident populations. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 13}
library(acs)
library(maps)
library(maptools)
key = "ba67d3a427e1f785987b9c8bc59341bf7c8a7cc1"
api.key.install(key)

crcog.towns = geo.make(state = "CT", 
                       county = paste(towns$County,"County"),
                       county.subdivision = paste(towns$Town,"town"), 
                       check = F, 
                       combine = T,
                       combine.term = "CRCOG region")

C15002I = acs.fetch(geography = crcog.towns, table.number = "C15002I", col.names = "pretty")
C15002B = acs.fetch(geography = crcog.towns, table.number = "C15002B", col.names = "pretty")
C15002H = acs.fetch(geography = crcog.towns, table.number = "C15002H", col.names = "pretty")

attainment.by.race = 
  rbind(data.frame(town=geography(C15002I)[[1]],
                 race = "Hispanic / Latino",
                 nohs=as.numeric(estimate(divide.acs(
                   numerator=(C15002I[,3] + C15002I[,8]),
                   denominator=(C15002I[,1])))),
                 hs=as.numeric(estimate(divide.acs(
                   numerator=(C15002I[,4] + C15002I[,9]),
                   denominator=(C15002I[,1])))),
                 somecollege=as.numeric(estimate(divide.acs(
                   numerator=(C15002I[,5] + C15002I[,10]),
                   denominator=(C15002I[,1])))),
                 college=as.numeric(estimate(divide.acs(
                   numerator=(C15002I[,6] + C15002I[,11]),
                   denominator=(C15002I[,1]))))),
        data.frame(town=geography(C15002B)[[1]],
                 race = "Black",
                 nohs=as.numeric(estimate(divide.acs(
                   numerator=(C15002B[,3] + C15002B[,8]),
                   denominator=(C15002B[,1])))),
                 hs=as.numeric(estimate(divide.acs(
                   numerator=(C15002B[,4] + C15002B[,9]),
                   denominator=(C15002B[,1])))),
                 somecollege=as.numeric(estimate(divide.acs(
                   numerator=(C15002B[,5] + C15002B[,10]),
                   denominator=(C15002B[,1])))),
                 college=as.numeric(estimate(divide.acs(
                   numerator=(C15002B[,6] + C15002B[,11]),
                   denominator=(C15002B[,1]))))),
      data.frame(town=geography(C15002H)[[1]],
                 race = "White",
                 nohs=as.numeric(estimate(divide.acs(
                   numerator=(C15002H[,3] + C15002H[,8]),
                   denominator=(C15002H[,1])))),
                 hs=as.numeric(estimate(divide.acs(
                   numerator=(C15002H[,4] + C15002H[,9]),
                   denominator=(C15002H[,1])))),
                 somecollege=as.numeric(estimate(divide.acs(
                   numerator=(C15002H[,5] + C15002H[,10]),
                   denominator=(C15002H[,1])))),
                 college=as.numeric(estimate(divide.acs(
                   numerator=(C15002H[,6] + C15002H[,11]),
                   denominator=(C15002H[,1]))))))

attainment.by.race <- melt(attainment.by.race)

ggplot(data = attainment.by.race, 
       aes(y = value, x = race, group = race, fill = variable)) + 
  geom_bar(position = 'fill', stat = 'identity') + 
  scale_y_continuous(labels = percent) +
  labs(x = NULL, y = '% of adults (2008 - 2012 ACS estimates)') +
  scale_fill_brewer(labels = c("Less than high school degree",
                               "High school graduate",
                               "Some college or associate's degree",
                               "Bachelor's degree or higher"), 
                    name = "") +
  coord_flip() + 
  theme_minimal(base_size = 16)

write.csv(attainment.by.race,"../rawdata/attainment.csv", row.names = FALSE)
```

--- 
## Job growth

While still providing many jobs, historically strong sectors (finance & insurance, manufacturing) have seen declines recently. Sectors with opportunities for growth involve service industries related to serving the needs of an aging, poorer population.  

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 13}
qcew <- read.csv('../mockup/qcewannual-t.csv')

qcew <- rbind(qcew,
              ddply(subset(qcew,naicsector > 100), .(area,series,year), summarise,
                    naicsector = 31,
                    sectortitle = "Manufacturing",
                    value = sum(value)))

jobgrowth <- cast(subset(qcew, series == "Employees" &
                           area == "North Central" &
                           naicsector < 100 & 
                           year %in% c(2013, 2003)),
                  sectortitle ~ year)
names(jobgrowth) <- make.names(names(jobgrowth))
jobgrowth$growth = jobgrowth$X2013 / jobgrowth$X2003 - 1

rising <- 
ggplot(data = subset(qcew, series == "Employees" &
                           area == "North Central" &
                           sectortitle %in% subset(jobgrowth, 
                                                   growth > .1 & 
                                                     X2013 > 10000)$sectortitle), 
       aes(y = value, x = year)) + 
  geom_line(aes(group = area)) +
  theme_minimal(base_size = 16) +
  labs(y = "Number of employees", x = NULL) +
  scale_x_continuous(breaks = c(1993,2003,2013)) +
  scale_y_continuous(labels = comma, lim = c(10000,100000)) + 
  facet_wrap(~ sectortitle, ncol = 4)

stable <- 
ggplot(data = subset(qcew, series == "Employees" &
                           area == "North Central" &
                           sectortitle %in% subset(jobgrowth, 
                                                   growth <= .1 & growth >= -.1 &
                                                     X2013 > 10000)$sectortitle), 
       aes(y = value, x = year)) + 
  geom_line(aes(group = area)) +
  theme_minimal(base_size = 16) +
  labs(y = "Number of employees", x = NULL) +
  scale_x_continuous(breaks = c(1993,2003,2013)) +
  scale_y_continuous(labels = comma, lim = c(10000,100000)) + 
  facet_wrap(~ sectortitle, ncol = 4)


falling <- 
ggplot(data = subset(qcew, series == "Employees" &
                           area == "North Central" &
                           sectortitle %in% subset(jobgrowth, 
                                                   growth < -.1 & 
                                                     X2013 > 10000)$sectortitle), 
       aes(y = value, x = year)) + 
  geom_line(aes(group = area)) +
  theme_minimal(base_size = 16) +
  labs(y = "Number of employees", x = NULL) +
  scale_x_continuous(breaks = c(1993,2003,2013)) +
  scale_y_continuous(labels = comma, lim = c(10000,100000)) + 
  facet_wrap(~ sectortitle, ncol = 4)


library(gridExtra)
grid.arrange(rising, falling, nrow = 1, ncol = 2)

write.csv(subset(qcew, series == "Employees" &
                           area == "North Central" &
                           sectortitle %in% subset(jobgrowth, X2013 > 10000)$sectortitle),
          "../rawdata/jobgrowth.csv", row.names = FALSE)
```

--- 
## Talent pipeline from schools

Where is future workforce? Don't know what future jobs will be, but best strategy is to have an educated population. High skills jobs (college+) will be most in demand. As in the workforce pipeline, academic achievement gaps exist among various resident populations. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 11}
hsgrad <- read.csv("../hsgraduation/hsgraduationrates-school.csv", 
                   na.strings = c("*","NA"))

#Filter to just regional districts
districts <- read.csv("../regionalreport/data/hartford-districts.csv")
hsgrad <- subset(hsgrad, hsgrad$District.Name %in% levels(districts$district))
hsgrad$District.Name <- factor(hsgrad$District.Name)

hsgrad_agg <- ddply(hsgrad, .(Category, Status), summarise,
                    mean = mean(X4.Year.Graduation..Rate, na.rm = T) / 100,
                    percent95 = quantile(X4.Year.Graduation..Rate, 0.95, na.rm = T)/ 100,
                    percent05 = quantile(X4.Year.Graduation..Rate, 0.05, na.rm = T) / 100)

hsgrad_agg$Status <- reorder(hsgrad_agg$Status, hsgrad_agg$mean)

#Remove the groups we don't want / need to report
hsgrad_agg <- subset(hsgrad_agg, !(Status %in% c("Two or More Races",
                                               "American Indian",
                                               "Hawaiian or Pacific Islander",
                                               "Non-Hispanic",
                                               "Non-ELL",
                                               "Non-Special Education",
                                               "Not Eligible For Lunch")))

#Show variation for region
ggplot(data = hsgrad_agg, aes(y = mean, x = Status)) + 
  geom_point() + 
  geom_errorbar(aes(ymin = percent05, ymax = percent95), width = 0.2) + 
  coord_flip() + 
  labs(title = '4-year graduation rate (average, + 5th / 95th percentiles)', y = NULL, 
       x = NULL) + 
  scale_y_continuous(labels = percent, lim = c(0,1)) + 
  theme_minimal()

write.csv(hsgrad_agg, "../rawdata/hsgraduation.csv", row.names = FALSE)
```

--- 
## Achievement gap starts early

As third grade reading scores indicate, there is an urgent need to addressing gaps in education early on, including even earlier in early childhood.  Gaps between ELL and special education students are most significant.

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 14}
library(gridExtra)
cmt_summary <- read.csv('../reviewversion/cmt-summary-2.csv', 
                        na.strings = c("-","NA"))
cmt_summary <- subset(cmt_summary, cmt_summary$Dist..ID %in% 
                        levels(as.factor(districts$districtid)))

#Clean up race categories - make compatible with old categories
cmt_summary <- subset(cmt_summary, Total.Reading > 0)

cmt_subgroups_region <- ddply(cmt_summary,.(Year, Category, Status),
                              summarise,
                              Average.Scale.Score = 
                                weighted.mean(
                                  Total.Reading.Average.Scale.Score, 
                                  Total.Reading, 
                                  na.rm = TRUE))

glr1 <- 
  ggplot(data = subset(cmt_subgroups_region, Category == "ELL"), 
         aes(x = Year, y = Average.Scale.Score)) + 
  geom_line(aes(group = Status, colour = Status), size = 1) +
  geom_hline(yintercept = c(202, 217, 235, 279), size = 2, alpha = 0.1) + 
  scale_x_continuous(breaks = c(2006,2009,2012)) +
  scale_y_continuous(breaks = c(202,217,235,279), lim = c(180,300)) +
  scale_colour_brewer(palette = "Dark2") + 
  theme_minimal() + 
  theme(legend.position = "top") +
  labs(x = NULL, y = "Average scale score, 3rd grade reading") + 
  guides(colour = guide_legend(ncol = 1, title = NULL))

glr2 <- 
  ggplot(data = subset(cmt_subgroups_region, Category == "Race / ethnicity" & 
                         Status != "Two or more races"), 
         aes(x = Year, y = Average.Scale.Score)) + 
  geom_line(aes(group = Status, colour = Status), size = 1) +
  geom_hline(yintercept = c(202, 217, 235, 279), size = 2, alpha = 0.1) + 
  scale_x_continuous(breaks = c(2006,2009,2012)) +
  scale_y_continuous(breaks = c(202,217,235,279), lim = c(180,300)) +
  scale_colour_brewer(palette = "Dark2") + 
  theme_minimal() + 
  theme(legend.position = "top") +
  labs(x = NULL, y = NULL) + 
  guides(colour = guide_legend(ncol = 2, title = NULL))

glr3 <- 
  ggplot(data = subset(cmt_subgroups_region, Category =="Free / Reduced Price Lunch"), 
         aes(x = Year, y = Average.Scale.Score)) + 
  geom_line(aes(group = Status, colour = Status), size = 1) +
  geom_hline(yintercept = c(202, 217, 235, 279), size = 2, alpha = 0.1) + 
  scale_x_continuous(breaks = c(2006,2009,2012)) +
  scale_y_continuous(breaks = c(202,217,235,279), lim = c(180,300)) +
  scale_colour_brewer(palette = "Dark2") + 
  theme_minimal() + 
  theme(legend.position = "top") +
  labs(x = NULL, y = NULL) + 
  guides(colour = guide_legend(ncol = 1, title = NULL))

glr4 <- 
  ggplot(data = subset(cmt_subgroups_region, Category == "Gender"), 
         aes(x = Year, y = Average.Scale.Score)) + 
  geom_line(aes(group = Status, colour = Status), size = 1) +
  geom_hline(yintercept = c(202, 217, 235, 279), size = 2, alpha = 0.1) + 
  scale_x_continuous(breaks = c(2006,2009,2012)) +
  scale_y_continuous(breaks = c(202,217,235,279), lim = c(180,300)) +
  scale_colour_brewer(palette = "Dark2") + 
  theme_minimal() + 
  theme(legend.position = "top") +
  labs(x = NULL, y = NULL) + 
  guides(colour = guide_legend(ncol = 1, title = NULL))

glr5 <- 
  ggplot(data = subset(cmt_subgroups_region, Category == "Special Education"), 
         aes(x = Year, y = Average.Scale.Score)) + 
  geom_line(aes(group = Status, colour = Status), size = 1) +
  geom_hline(yintercept = c(202, 217, 235, 279), size = 2, alpha = 0.1) + 
  scale_x_continuous(breaks = c(2006,2009,2012)) +
  scale_y_continuous(breaks = c(202,217,235,279), lim = c(180,300)) +
  scale_colour_brewer(palette = "Dark2") + 
  theme_minimal() + 
  theme(legend.position = "top") + 
  labs(x = NULL, y = NULL) + 
  guides(colour = guide_legend(ncol = 1, title = NULL))

grid.arrange(glr1, glr2, glr3, glr4, glr5, ncol = 5, nrow = 1)

write.csv(cmt_subgroups_region,"../rawdata/3rdgradereading.csv", row.names = FALSE)
```


--- 
## What makes a vibrant community?

Significant gap in the number homeowners Hartford versus neighboring communities in the region. Lack of affordable housing outside of Hartford leads to high levels of concentrated poverty in the city. Affordable housing options in suburban communities must be increased. Crime in Hartford has declined but neighboring communities still enjoy higher levels of public safety. Residents who can afford to live in low-crime areas outside the city will do so. Lack of engagement in the electoral process makes it difficult for city residents to make changes in their community. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 13}
library(acs)
library(maps)
library(maptools)
library(gridExtra)
key = "ba67d3a427e1f785987b9c8bc59341bf7c8a7cc1"
api.key.install(key)
hartford.towns = geo.make(state = "CT", county = c("Hartford","Tolland"), county.subdivision = "*", check = F)
B25008 = acs.fetch(geography = hartford.towns, table.number = "B25008", col.names = "pretty", year = 2012)
own.estimate = divide.acs(numerator=B25008[,2],denominator=B25008[,1], method = 'proportion')
homeownership = data.frame(Town=geography(B25008)[[1]], 
                           number=as.numeric(estimate(B25008[,2])),
                           rate=as.numeric(estimate(own.estimate)),
                           se=standard.error(own.estimate))
names(homeownership) <- c("Town","number","rate","se")

homeownership$Town= gsub(" town, Tolland County, Connecticut", "", homeownership$Town)
homeownership$Town= gsub(" town, Hartford County, Connecticut", "", homeownership$Town)

home <- 
ggplot(data = ddply(merge(homeownership, towns,by = "Town"),.(Towngroup), summarise,
                    rate = weighted.mean(rate, 
                                         number, 
                                         na.rm = TRUE)),
       aes(x = Towngroup, y = rate)) + 
  geom_bar(stat = 'identity', width = 0.5) + 
  labs(x = NULL, y = "Population in owner-occupied housing units", 
       title = "Homeownership") + 
  scale_y_continuous(labels = percent) + 
  coord_flip() + 
  theme_minimal()

write.csv(ddply(merge(homeownership, towns,by = "Town"),.(Towngroup), summarise,
                    rate = weighted.mean(rate, 
                                         number, 
                                         na.rm = TRUE)),
          "../rawdata/homeownership.csv", row.names = FALSE)

#Affordable housing section
appeals <- read.csv('../housingcost/appeals-list-2012.csv')

appeals <- subset(appeals, appeals$Town %in% levels(towns$Town))

affordable  <- 
ggplot(data = ddply(merge(appeals, towns,by = "Town"),.(Towngroup), summarise,
                    Percent.Affordable =
                      weighted.mean(Percent.Affordable, 
                                    Total.housing.units...2010.census, na.rm = TRUE)),
       aes(x = Towngroup, y = Percent.Affordable)) + 
  geom_bar(stat = 'identity', width = 0.5) + 
  labs(x = NULL, y = "Percent affordable housing (rent and own)", 
       title = "Affordable housing") + 
  scale_y_continuous(labels = percent) + 
  coord_flip() + 
  theme_minimal()

write.csv(ddply(merge(appeals,towns,by = "Town"),
                    .(Towngroup, Year), summarise,
                    Percent.Affordable =
                      weighted.mean(Percent.Affordable, 
                                    Total.housing.units...2010.census, na.rm = TRUE)),
          "../rawdata/affordablehousing.csv",row.names = FALSE)

#Crime section
totalcrime <- read.csv("../crime/totalcrime.csv")
totalcrime <- subset(totalcrime, totalcrime$Town %in% levels(towns$Town))
totalcrime$Town <- factor(totalcrime$Town)

crime <- 
ggplot(data = ddply(merge(subset(totalcrime, Year > 2008),
                          towns,by = "Town"),.(Towngroup), summarise,
                    Total.crime.Rate =
                      weighted.mean(Total.crime.Rate, 
                                    Total.estimated.population..Number, na.rm = TRUE)),
       aes(x = Towngroup, y = Total.crime.Rate)) + 
  geom_bar(stat = 'identity', width = 0.5) + 
  labs(x = NULL, y = "Crimes per 100K residents", title = "Crime rate") + 
  scale_y_continuous(labels = comma) + 
  coord_flip() + 
  theme_minimal()

write.csv(ddply(merge(subset(totalcrime[!is.na(totalcrime$Total.crime.Rate),]),
                                 towns,by = "Town"),
                    .(Towngroup, Year), summarise,
                    Total.crime.Rate =
                      weighted.mean(Total.crime.Rate, 
                                    Total.estimated.population..Number, na.rm = TRUE)),
          "../rawdata/crime.csv",row.names = FALSE)

#Voting section
voting <- read.csv('../reviewversion/voting.csv')
#voting$Town <- gsub(pattern = " (CD1&2)", replacement = "", voting$Town)
voting <- subset(voting, voting$Town %in% levels(towns$Town))


vote <- 
ggplot(data = ddply(merge(subset(voting, Type == "Municipal"),
                          towns,by = "Town"),.(Year,Towngroup,Type), 
                    summarise,
                    Percentage.Checked.as.Having.Voted =
                      weighted.mean(Percentage.Checked.as.Having.Voted,
                                    Names.on.Official.Check.List..Active.,na.rm = TRUE)),
       aes(x = Towngroup, y = Percentage.Checked.as.Having.Voted)) + 
  geom_bar(stat = 'identity', width = 0.5) + 
  labs(x = NULL, y = "Percent of registered voters that voted, municipal elections", 
       title = "Voter turnout, municipal elections") + 
  scale_y_continuous(labels = percent) + 
  coord_flip() + 
  theme_minimal()

write.csv(ddply(merge(subset(voting, Type == "Municipal"),towns,by = "Town"),
                    .(Towngroup, Year), summarise,
                    Percentage.Checked.as.Having.Voted =
                      weighted.mean(Percentage.Checked.as.Having.Voted,
                                    Names.on.Official.Check.List..Active.,na.rm = TRUE)),
      "../rawdata/voterturnout.csv",row.names = FALSE)

grid.arrange(home,affordable,crime,vote, ncol = 2, nrow = 4)
```


--- 
## What makes a vibrant community?

Version with trend graphs instead 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 12, fig.width = 13}
library(acs)
library(maps)
library(maptools)
library(gridExtra)
key = "ba67d3a427e1f785987b9c8bc59341bf7c8a7cc1"
api.key.install(key)
hartford.towns = geo.make(state = "CT", county = c("Hartford","Tolland"), county.subdivision = "*", check = F)
B25008 = acs.fetch(geography = hartford.towns, table.number = "B25008", col.names = "pretty", year = 2012)
own.estimate = divide.acs(numerator=B25008[,2],denominator=B25008[,1], method = 'proportion')
homeownership = data.frame(Town=geography(B25008)[[1]], 
                           number=as.numeric(estimate(B25008[,2])),
                           rate=as.numeric(estimate(own.estimate)),
                           se=standard.error(own.estimate))
names(homeownership) <- c("Town","number","rate","se")

homeownership$Town= gsub(" town, Tolland County, Connecticut", "", homeownership$Town)
homeownership$Town= gsub(" town, Hartford County, Connecticut", "", homeownership$Town)

home <- 
ggplot(data = ddply(merge(homeownership, towns,by = "Town"),.(Towngroup), summarise,
                    rate = weighted.mean(rate, 
                                         number, 
                                         na.rm = TRUE)),
       aes(x = Towngroup, y = rate)) + 
  geom_bar(stat = 'identity', width = 0.5) + 
  labs(x = NULL, y = "Population in owner-occupied housing units", 
       title = "Homeownership") + 
  scale_y_continuous(labels = percent) + 
  coord_flip() + 
  theme_minimal()

#Affordable housing section
appeals <- read.csv('../housingcost/appeals-list-2012.csv')

appeals <- subset(appeals, appeals$Town %in% levels(towns$Town))

affordable  <- 
ggplot(data = ddply(merge(appeals,towns,by = "Town"),
                    .(Towngroup, Year), summarise,
                    Percent.Affordable =
                      weighted.mean(Percent.Affordable, 
                                    Total.housing.units...2010.census, na.rm = TRUE)),
       aes(x = Year, y = Percent.Affordable, group = Towngroup)) + 
  geom_line(aes(colour = Towngroup), size = 1) + 
  labs(x = NULL, y = "Percent affordable housing", 
       title = "Affordable housing") +  
  scale_y_continuous(labels = percent, lim = c(0,.4)) + 
  theme_minimal()

#Crime section
totalcrime <- read.csv("../crime/totalcrime.csv")
totalcrime <- subset(totalcrime, totalcrime$Town %in% levels(towns$Town))
totalcrime$Town <- factor(totalcrime$Town)

crime <- 
ggplot(data = ddply(merge(subset(totalcrime[!is.na(totalcrime$Total.crime.Rate),]),
                                 towns,by = "Town"),
                    .(Towngroup, Year), summarise,
                    Total.crime.Rate =
                      weighted.mean(Total.crime.Rate, 
                                    Total.estimated.population..Number, na.rm = TRUE)),
       aes(x = Year, y = Total.crime.Rate, group = Towngroup)) + 
  geom_line(aes(colour = Towngroup), size = 1) + 
  labs(x = NULL, y = "Crimes per 100K residents", title = "Crime rate") + 
  scale_y_continuous(labels = comma) + 
  theme_minimal()

#Voting section
voting <- read.csv('../reviewversion/voting.csv')
#voting$Town <- gsub(pattern = " (CD1&2)", replacement = "", voting$Town)
voting <- subset(voting, voting$Town %in% levels(towns$Town))

vote <- 
ggplot(data = ddply(merge(subset(voting, Type == "Municipal"),towns,by = "Town"),
                    .(Towngroup, Year), summarise,
                    Percentage.Checked.as.Having.Voted =
                      weighted.mean(Percentage.Checked.as.Having.Voted,
                                    Names.on.Official.Check.List..Active.,na.rm = TRUE)),
       aes(x = Year, y = Percentage.Checked.as.Having.Voted, group = Towngroup)) + 
  geom_line(aes(colour = Towngroup), size = 1) + 
  labs(x = NULL, y = "Percent of registered voters that voted", 
       title = "Voter turnout, municipal elections") + 
  scale_y_continuous(labels = percent, lim = c(0,1)) + 
  theme_minimal()

grid.arrange(home,affordable,crime,vote, ncol = 2, nrow = 4)
```
