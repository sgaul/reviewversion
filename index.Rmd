---
title       : Review version of top indicators
subtitle    : Hartford regional indicators
author      : 
job         : Community Indicators Project
framework   : io2012        # {io2012, html5slides, shower, dzslides, minimal ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      # 
ext_widgets : {rCharts: ["libraries/nvd3"]} 
mode        : selfcontained # {standalone, draft}

--- &twocol
## Outline of indicators

*** =left
Background on the region
* Population / diversity
* Commuting patterns
* School enrollment
* Income levels and poverty rates

Education
* 3rd grade reading
* High school graduation rate

*** =right
Jobs
* Educational attainment
* Job growth

Quality of life / civic health
* Home ownership
* Affordable housing
* Crime rate
* Voter turnout

---
## Key themes

1. 'We are a region'
2. Concentration of poverty in Hartford
3. Suburbanization of poverty
4. Aging population and workforce
5. Globally connected region
6. Achievement gap and talent pipeline
7. Creating opportunity in communities throughout the region

---

## Defining the region: Hartford + surrounding towns

CRCOG region. Based on characteristics of each town, using UConn categories from [5 CTs report](http://ctsdc.uconn.edu/projections/5cts.html), with slight updates. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 14}
towns <- read.csv("../regionalreport/data/hartford-towns.csv")

choropleth=merge(CTTowns, towns, by.x = "id", by.y="Town")
choropleth=choropleth[order(choropleth$order), ]

#Make the map
ggplot(data = choropleth, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = Towngroup)) + 
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = NULL, y = NULL) + 
  coord_equal() +
  geom_polygon(data = CTTowns, colour = "grey", alpha = 0.5, fill = NA) +
  scale_fill_brewer(palette = "Purples", name = "Types of towns") +
  theme_minimal(base_size = 16)

write.csv(towns,"slide4.csv", row.names = FALSE)
```

---
## Low population growth

Low population growth overall; losing population in center city, slow outside, most rapid in outer suburbs. Not great at attracting people to the region. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 12}
library(ggplot2)
library(scales)
library(reshape)

gh <- read.csv("../regionalreport/data/greaterhartford.csv")
gh$poppoverty <- round((gh$poppovertyrate / 100) * gh$population,0)
gh_test <- ddply(merge(gh,towns,by.x = "city", by.y = "Town"),
                 .(period,Towngroup), summarise, 
                 sumpop = sum(population),
                 sumpoor = sum(poppoverty))

ggplot() + 
  geom_line(data = subset(gh_test, period >= 1900 & period <= 2010), size = 1, 
            aes(x = period, y = sumpop, group = Towngroup, colour = Towngroup)) + 
  geom_line(data = subset(gh_test, period >= 2010), linetype = 'dotted', size = 1,
            aes(x = period, y = sumpop, group = Towngroup, colour = Towngroup)) + 
  theme_minimal(base_size = 16) + 
  scale_y_continuous(labels = comma, lim = c(0,500000)) +  
  labs(x = "Year", y = "Population")

write.csv(subset(gh_test, period >= 1900),"slide5.csv", row.names = FALSE)
```

--- 
## Suburbanization of poverty

New poverty will occur in suburbs, new challenges towns can't ignore. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 13}
gh <- merge(gh,towns, by.x = "city", by.y = "Town")

gh_sum <- ddply(gh,.(Towngroup, period), summarise, population = sum(population), population.under.poverty = sum(poppoverty))

ggplot(aes(y = population.under.poverty, 
           x = period), data = subset(gh_sum,period >= 1970)) + 
  geom_line(aes(group = Towngroup, colour = Towngroup), size = 1) + 
  scale_y_continuous(labels = comma, limits = c(0,41000)) + 
  labs(x = "Year", y = 'Population') +
  theme_minimal(base_size = 16)

write.csv(subset(gh_sum,period >= 1970),"slide6.csv", row.names = FALSE)
```

---
## Aging population

Suburbs are aging quickly and not good prospects for replacing with younger generation, based on current projections. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 12}
projections <- read.csv('../reviewversion/sdc-projections.csv')
towns <- read.csv("../regionalreport/data/hartford-towns.csv")
projections <- subset(projections, projections$TOWN %in% levels(towns$Town))
projections$TOWN <- factor(projections$TOWN)
projections$YEAR <- paste("20",projections$YEAR, sep = "")

projections <- merge(projections, towns, by.x = "TOWN", by.y = "Town")

levels(projections$AGE) <- list(
  "55 years and over" = c("8084","6064","7579","5559","90OV","7074","8589","6569"),
  "25 to 54 years" = c("4549","2529","4044","3539","5054","3034"),
  "16 to 24 years" = c("2024","1519"),
  "0 to 16 years" = c("0004","0509","1014","4","509"))

#projections$TYPE = ifelse(projections$TOWN == "Hartford","Hartford","Other region")

#aging <- ddply(projections, .(YEAR, AGE, GENDER, TYPE), summarise, sum = sum(value))
#aging <- cast(aging, TYPE + YEAR + AGE ~ GENDER)

#levels(aging$AGE) <- rev(levels(aging$AGE))

projections$AGE <- factor(projections$AGE, levels = c("0 to 16 years",
                                                      "16 to 24 years",
                                                      "25 to 54 years",
                                                      "55 years and over"))

projections$Towngroup <- factor(projections$Towngroup, levels = c("Hartford",
                                                                  "Urban periphery",
                                                                  "Suburban / rural"))

ggplot(data = 
         ddply(projections, .(YEAR, AGE, Towngroup), summarise, value = sum(value)),
       aes(x = YEAR, y = value)) + 
  geom_line(aes(group = AGE, colour = AGE), size = 1, linetype = 'dotted') +
  geom_point(aes(group = AGE, colour = AGE, shape = AGE)) +
  facet_wrap(~ Towngroup, ncol = 3) +
  scale_fill_brewer(name = "Age") +
  scale_y_continuous(labels = comma) + 
  labs(y = "Population", x = "Year") +
  theme_minimal(base_size = 16)

write.csv(ddply(projections, .(YEAR, AGE, Towngroup), summarise, value = sum(value)),'slide7.csv', row.names = F)
```

--- 
## School enrollment declining

Aging population reflected in overall declining school enrollment. Local schools hit twice - once with demographics, again through increase in magnet / private enrollment.

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 14}
enroll <- read.csv("../regionalreport/data/all-schools.csv", stringsAsFactors=FALSE)

#Filter out the towns that are not in the region and clear out the factors
enroll <- subset(enroll, enroll$Resident.Town %in% levels(towns$Town))
enroll$Resident.Town <- factor(enroll$Resident.Town)

charters <- data.frame(charters = c("The Bridge Academy District",
                            "Trailblazers Academy District",
                            "Side By Side Community School District",
                            "Park City Prep Charter School",
                            "Odyssey Community School District",
                            "New Beginnings Inc., Family Academy District",
                            "Jumoke Academy District",
                            "Highville Charter School District",  
                            "Highville Mustard Seed Charter School District",       
                            "Integrated Day Charter School District",        
                            "Interdistrict School for Arts and Comm District",
                            "Explorations District",
                            "Elm City College Preparatory School",
                            "Common Ground High School District",
                            "Charter School for Young Children on Asylum Hill",
                            "Bridgeport Achievement First",
                            "Achievement First Hartford Academy Inc.",                
                            "Amistad Academy District"))

#Make the charters into their own category
enroll$School.Type[enroll$Sent.to.District %in% levels(charters[,])] <- 'Public charter'

#Replace the less frequent school types with 'Other'
enroll$School.Type <- gsub("Homebound","Other",enroll$School.Type)
enroll$School.Type <- gsub("Voag","Other",enroll$School.Type)
enroll$School.Type <- gsub("Interdistrict Cooperative Agreement","Other",enroll$School.Type)
enroll$School.Type <- gsub("Designated High School","Other",enroll$School.Type)
enroll$School.Type <- gsub("Nonpublic","Private",enroll$School.Type)

#Melt the dataset to get it into a more normalized format for plotting
enroll <- melt(enroll, 
               measure.vars = c("PK","K","G1","G2","G3","G4","G5","G6","G7","G8","G9","G10","G11","G12","Total"),
               id.vars = c("Resident.Town.ID","District.ID","Resident.Town","Sent.to.District","School.Year","School.Type"))

#Get rid of the sent to districts since there are multiple districts for each
enroll <- aggregate(enroll$value,
                    list(Resident.Town = enroll$Resident.Town, 
                         School.Year = enroll$School.Year, 
                         School.Type = enroll$School.Type, 
                         variable = enroll$variable), 
                    sum)

#Sort the school types for the display
enroll$School.Type <- factor(enroll$School.Type, levels = c("Public",
                                                            "Private",
                                                            "Public charter",
                                                            "Magnet School",
                                                            "Open Choice","Other"))

ggplot(data = ddply(merge(subset(enroll, variable == "Total"), towns, 
                          by.x = "Resident.Town",by.y = "Town"),
      .(Towngroup, School.Type, School.Year),summarise, x = sum(x)),
       aes(x = School.Year, y = x, group = School.Type, fill = School.Type)) +
  geom_line(aes(group = School.Type, colour = School.Type)) +
  geom_point(aes(group = School.Type, colour = School.Type, shape = School.Type)) +
  scale_y_continuous(labels = comma) +
  scale_x_discrete(breaks = c("2006-07","2008-09","2010-11")) +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 16) +
  facet_wrap(~ Towngroup, ncol = 3)

write.csv(ddply(merge(subset(enroll, variable == "Total"), towns, 
                          by.x = "Resident.Town",by.y = "Town"),
      .(Towngroup, School.Type, School.Year),summarise, x = sum(x)), 
          "slide8.csv", row.names = FALSE)

write.csv(subset(otm, ratio > 0.05 & !(Destination == "All Other Locations")), 
          "slide9.csv", row.names = FALSE)
```

--- 
## Linguistic diversity

Diversity part of changing population (tie back to 1st chart); which suburbs will 'globalize'? Where will new population in our region come from? (Add refugee factoid.)

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 12}
languages <- read.csv('../reviewversion/Languages-all.csv', na.strings = c("**","-"))
districts <- read.csv("../regionalreport/data/hartford-districts.csv")
languages <- merge(languages, districts, by.x = "District.Name", by.y = "district")

languages_agg <- merge(ddply(languages, .(District.Name), summarise,all.lang = length(unique(Languages)),all.students = sum(Number.of.Students.with.Non.English.Home.Language, na.rm = TRUE)),
                       ddply(subset(languages, Number.of.ELL.Students > 0),
                             .(District.Name), summarise,ell.lang = length(unique(Languages)),ell.students = sum(Number.of.ELL.Students, na.rm = TRUE)),
                       by = "District.Name", 
                       all = TRUE)

#All linguistic diversity
languages_agg$District.Name <- reorder(languages_agg$District.Name,
                                       languages_agg$all.lang)

ggplot(data = languages_agg) + 
  geom_point(aes(x = all.lang, y = District.Name)) + 
  labs(x = 'Number of languages spoken, all students', y = NULL) + 
  scale_x_continuous(labels = comma) + 
  theme_minimal(base_size = 16)

write.csv(languages,'slide10.csv', row.names = F)
```

--- 
## Everyone commutes, mostly to Hartford

Globally connected city via employers as well. Draws high-skill jobs to the region, so people commute to the job centers (Hartford and some other towns).

![image](../mockup/commute-patterns.png)

--- 
## Demand for a skilled workforce

Commuting and the next 2 slides together, making the case that region has high skilled jobs as an asset, but skills not equitably distributed in the workforce. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 13}
library(acs)
library(maps)
library(maptools)
key = "ba67d3a427e1f785987b9c8bc59341bf7c8a7cc1"
api.key.install(key)

crcog.towns = geo.make(state = "CT", 
                       county = paste(towns$County,"County"),
                       county.subdivision = paste(towns$Town,"town"), 
                       check = F, 
                       combine = T,
                       combine.term = "CRCOG region")

C15002I = acs.fetch(geography = crcog.towns, table.number = "C15002I", col.names = "pretty")
C15002B = acs.fetch(geography = crcog.towns, table.number = "C15002B", col.names = "pretty")
C15002H = acs.fetch(geography = crcog.towns, table.number = "C15002H", col.names = "pretty")

attainment.by.race = 
  rbind(data.frame(town=geography(C15002I)[[1]],
                 race = "Hispanic / Latino",
                 nohs=as.numeric(estimate(divide.acs(
                   numerator=(C15002I[,3] + C15002I[,8]),
                   denominator=(C15002I[,1])))),
                 hs=as.numeric(estimate(divide.acs(
                   numerator=(C15002I[,4] + C15002I[,9]),
                   denominator=(C15002I[,1])))),
                 somecollege=as.numeric(estimate(divide.acs(
                   numerator=(C15002I[,5] + C15002I[,10]),
                   denominator=(C15002I[,1])))),
                 college=as.numeric(estimate(divide.acs(
                   numerator=(C15002I[,6] + C15002I[,11]),
                   denominator=(C15002I[,1]))))),
        data.frame(town=geography(C15002B)[[1]],
                 race = "Black",
                 nohs=as.numeric(estimate(divide.acs(
                   numerator=(C15002B[,3] + C15002B[,8]),
                   denominator=(C15002B[,1])))),
                 hs=as.numeric(estimate(divide.acs(
                   numerator=(C15002B[,4] + C15002B[,9]),
                   denominator=(C15002B[,1])))),
                 somecollege=as.numeric(estimate(divide.acs(
                   numerator=(C15002B[,5] + C15002B[,10]),
                   denominator=(C15002B[,1])))),
                 college=as.numeric(estimate(divide.acs(
                   numerator=(C15002B[,6] + C15002B[,11]),
                   denominator=(C15002B[,1]))))),
      data.frame(town=geography(C15002H)[[1]],
                 race = "White",
                 nohs=as.numeric(estimate(divide.acs(
                   numerator=(C15002H[,3] + C15002H[,8]),
                   denominator=(C15002H[,1])))),
                 hs=as.numeric(estimate(divide.acs(
                   numerator=(C15002H[,4] + C15002H[,9]),
                   denominator=(C15002H[,1])))),
                 somecollege=as.numeric(estimate(divide.acs(
                   numerator=(C15002H[,5] + C15002H[,10]),
                   denominator=(C15002H[,1])))),
                 college=as.numeric(estimate(divide.acs(
                   numerator=(C15002H[,6] + C15002H[,11]),
                   denominator=(C15002H[,1]))))))

attainment.by.race <- melt(attainment.by.race)

ggplot(data = attainment.by.race, 
       aes(y = value, x = race, group = race, fill = variable)) + 
  geom_bar(position = 'fill', stat = 'identity') + 
  scale_y_continuous(labels = percent) +
  labs(x = NULL, y = '% of adults (2008 - 2012 ACS estimates)') +
  scale_fill_brewer(labels = c("Less than high school degree",
                               "High school graduate",
                               "Some college or associate's degree",
                               "Bachelor's degree or higher"), 
                    name = "") +
  coord_flip() + 
  theme_minimal(base_size = 16)

write.csv(attainment.by.race,"slide11.csv", row.names = FALSE)
```

--- 
## Job growth

And job growth in historically strong sectors (finance & insurance, manufacturing) has not been strong recently. Changes in job market - strengths are strengths no longer. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 13}
qcew <- read.csv('../mockup/qcewannual-t.csv')

qcew <- rbind(qcew,
              ddply(subset(qcew,naicsector > 100), .(area,series,year), summarise,
                    naicsector = 31,
                    sectortitle = "Manufacturing",
                    value = sum(value)))

jobgrowth <- cast(subset(qcew, series == "Employees" &
                           area == "North Central" &
                           naicsector < 100 & 
                           year %in% c(2013, 2003)),
                  sectortitle ~ year)
names(jobgrowth) <- make.names(names(jobgrowth))
jobgrowth$growth = jobgrowth$X2013 / jobgrowth$X2003 - 1

jobgrowth$sectortitle <- reorder(jobgrowth$sectortitle, jobgrowth$growth)

ggplot(data = subset(jobgrowth, X2013 > 1000 & 
                       sectortitle != "Total - All Industries"), 
       aes(x = growth, y = sectortitle)) + 
  geom_point(aes(size = X2013)) +
  theme_minimal(base_size = 16) +
  scale_size(name = "Number of\n employees (2013)") + 
  labs(x = "Growth (2010 - 2013)", y = "Sector") +
  scale_x_continuous(labels = percent)

write.csv(subset(jobgrowth, X2013 > 1000 & sectortitle != "Total - All Industries"),
          "slide12.csv", row.names = FALSE)
```

--- 
## Talent pipeline from schools

Where is future workforce? Don't know what future jobs will be, but best strategy is to have an educated population. High skills jobs (college+) will be most in demand.

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 11}
hsgrad <- read.csv("../hsgraduation/hsgraduationrates-district.csv")

#Filter to just regional districts
districts <- read.csv("../regionalreport/data/hartford-districts.csv")
hsgrad <- subset(hsgrad, hsgrad$District.Name %in% levels(districts$district))
hsgrad$District.Name <- factor(hsgrad$District.Name)

#Clean up categories
hsgrad$Category <- gsub(pattern = "^Indian$", replacement = "American Indian", hsgrad$Category)
hsgrad$Category <- gsub(pattern = "Asian American", replacement = "Asian", hsgrad$Category)
hsgrad$Category <- gsub(pattern = "Asian ", replacement = "Asian", hsgrad$Category)
hsgrad$Category <- gsub(pattern = "Non- Special", replacement = "Non-Special", hsgrad$Category)

#Merge with enrollment data to allow aggregation
#Doing this with entire enrollment for the school, need better data by year
hsenroll <- read.csv("../hsgraduation/Race_and_Gender_by_district_2011_for_N_5_suppressed.csv")
hsenroll <- melt(hsenroll, id.vars = c("Inst","dist","District.Name"))
hsenroll$variable <- gsub(pattern = "All.Students", replacement = "All Students", hsenroll$variable)

gradenroll <- merge(hsgrad, hsenroll, by.x = c("District.Name","Category"), by.y = c("District.Name","variable"))

#Show trends for region
gradregion <- ddply(gradenroll, .(Category), summarise, 
                    wm = weighted.mean(X4.Year.Graduation.Rate, value, na.rm = TRUE))

gradregion$Category <- reorder(gradregion$Category, gradregion$wm)

ggplot(data = subset(gradregion, !(Category %in% c("American Indian")))) + 
  geom_point(aes(x = Category, y = wm)) + 
  coord_flip() + 
  ylim(0,100) +
  theme_minimal(base_size = 16) + 
  geom_hline(yintercept = 82.18249, alpha = 0.5) + 
  labs(x = NULL, y = "Average four-year graduation rate by major subgroup (2003 - 2011)")

write.csv(subset(gradregion, !(Category %in% c("American Indian"))),"slide13.csv", 
          row.names = FALSE)
```

--- 
## Achievement gap starts early

And can start addressing gaps in education early on, including even earlier in early childhood. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 14}
cmt_subgroups <- read.csv('../testscores/cmt-subgroups.csv', na.strings = c("**","-"))
cmt_subgroups <- subset(cmt_subgroups, cmt_subgroups$District.ID %in% 
                     levels(as.factor(districts$districtid)))

#Clean up race categories - make compatible with old categories
cmt_subgroups$Status = gsub(x = cmt_subgroups$Status, 
                                pattern = "American Indian/Alaska Native",
                                replacement = "American Indian")

cmt_subgroups$Status = gsub(x = cmt_subgroups$Status, 
                                pattern = "Black/African American",
                                replacement = "Black, not of Hispanic Origin")

cmt_subgroups$Status = gsub(x = cmt_subgroups$Status, 
                                pattern = "(White$)",
                                replacement = "White, not of Hispanic Origin")

cmt_subgroups <- subset(cmt_subgroups, Students.Tested > 0)

cmt_subgroups_region <- ddply(cmt_subgroups,.(School.Year, Subgroup, Status),
                              summarise,
                              Percent.at.or.Above.Goal = weighted.mean(Percent.at.or.Above.Goal, Students.Tested, na.rm = TRUE),
                              Average.Scale.Score = weighted.mean(Average.Scale.Score, Students.Tested, na.rm = TRUE))
#Show trends for the region
ggplot(data = cmt_subgroups_region, aes(x = School.Year, y = Average.Scale.Score)) + 
  geom_line(aes(group = Status)) + 
#  geom_point(aes(group = Status)) + 
  facet_wrap(~ Subgroup, ncol = 5) + 
  scale_x_discrete(breaks = c("2006-07","2008-09","2010-11")) +
  theme_minimal(base_size = 16) + 
  labs(x = "School Year", y = "Average scale score, 3rd grade reading")

write.csv(cmt_subgroups_region,"slide14.csv", row.names = FALSE)
```

--- 
## What makes a vibrant community?

Creating opportunity in the region, what makes 'vibrant communities'? Knit together four slides with maps of region for homeownership, crime, affordable housing and voting. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 11}
library(acs)
library(maps)
library(maptools)
key = "ba67d3a427e1f785987b9c8bc59341bf7c8a7cc1"
api.key.install(key)
hartford.tracts = geo.make(state = "CT", county = c("Hartford","Tolland"), tract = "*", check = F)
B25008 = acs.fetch(geography = hartford.tracts, table.number = "B25008", col.names = "pretty", year = 2012)
own.estimate = divide.acs(numerator=B25008[,2],denominator=B25008[,1], method = 'proportion')
homeownership.tract = data.frame(tract=geography(B25008)[[1]], 
                         rate=as.numeric(estimate(own.estimate)),
                         se=standard.error(own.estimate))
names(homeownership.tract) <- c("tract","rate","se")

homeownership.tract$tract= gsub("Census Tract ", "", homeownership.tract$tract)
homeownership.tract$tract= gsub(", Tolland County, Connecticut", "",
                                homeownership.tract$tract)
homeownership.tract$tract= gsub(", Hartford County, Connecticut", "", 
                                homeownership.tract$tract)

#Load the UConn tract and town-level shapefiles
CTTracts <- readShapeSpatial(fn="../tractct_37800_0000_2010_s100_census_1_shp/wgs84/tractct_37800_0000_2010_s100_census_1_shp_wgs84")
CTTracts <- fortify(CTTracts, region = "NAME10")
CTTracts <- CTTracts[order(CTTracts$order),]
#Load the UConn shapefile
CTTowns <- readShapeSpatial(fn="../townshp/wgs84/townct_37800_0000_2010_s100_census_1_shp_wgs84")
#Fortify and order the CTTowns to allow ggmap to use that
CTTowns <- fortify(CTTowns, region = "NAME10")
CTTowns <- CTTowns[order(CTTowns$order),]
#Merge with data
library(classInt)
jenks <- classIntervals(homeownership.tract$rate, 
                        n=4, style="fisher")
choropleth=merge(CTTracts, homeownership.tract, by.x = "id", by.y="tract")
choropleth=choropleth[order(choropleth$order), ]
choropleth$rate=cut(choropleth$rate, 
                          breaks=jenks$brks,
                          include.lowest=T, dig.lab = T)
#Make the map
ggplot(data = choropleth, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = rate)) + 
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = NULL, y = NULL) + 
  coord_equal() +
  geom_polygon(data = CTTowns, colour = "grey", alpha = 0.1, fill = NA) +
  scale_fill_brewer(palette = "Purples", name = "% owner-occupied\nhousing") +
  theme_minimal(base_size = 16)

write.csv(homeownership.tract,"slide15.csv", row.names = FALSE)
```

--- 
## Affordable housing

Part of creating opportunity outside areas of concentrated poverty. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 11}
appeals <- read.csv('../housingcost/appeals-list-2012.csv')

appeals <- subset(appeals, appeals$Town %in% levels(towns$Town) & Year == 2012)

#appeals <- merge(appeals,towns, by = "Town")

#appeals <- merge(appeals, subset(gh, period == 2010), by.x = "Town", by.y = "city")

library(classInt)
jenks <- classIntervals(appeals$Percent.Affordable, 
                        n=4, style="fisher")
choropleth=merge(CTTowns, appeals, by.x = "id", by.y="Town")
choropleth=choropleth[order(choropleth$order), ]
choropleth$Percent.Affordable=cut(choropleth$Percent.Affordable, 
                          breaks=jenks$brks,
                          include.lowest=T, dig.lab = T)
#Make the map
ggplot(data = choropleth, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = Percent.Affordable)) + 
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = NULL, y = NULL) + 
  coord_equal() +
  geom_polygon(data = CTTowns, colour = "grey", alpha = 0.5, fill = NA) +
  scale_fill_brewer(palette = "Purples", name = "% Affordable\nHousing (2012)") +
  theme_minimal()

write.csv(appeals,"slide16.csv",row.names = FALSE)
```

--- 
## Hartford getting safer

Choice in housing based on factors like schools and safety. Doing better but still understandable that those who can afford to live in low-crime towns. 

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 11}
totalcrime <- read.csv("../crime/totalcrime.csv")
totalcrime <- subset(totalcrime, totalcrime$Town %in% levels(towns$Town))
totalcrime$Town <- factor(totalcrime$Town)
totalcrime_avg <- ddply(subset(totalcrime, Year > 2005), .(Town), summarise, 
                    Total.crime.Rate = weighted.mean(Total.crime.Rate, Total.estimated.population..Number, na.rm = TRUE))

library(classInt)
jenks <- classIntervals(totalcrime_avg$Total.crime.Rate, 
                        n=3, style="fisher")
choropleth=merge(CTTowns, totalcrime_avg, by.x = "id", by.y="Town")
choropleth=choropleth[order(choropleth$order), ]
choropleth$Total.crime.Rate= cut(choropleth$Total.crime.Rate, 
                          breaks=jenks$brks,
                          include.lowest=T, dig.lab = T)
#Make the map
ggplot(data = choropleth, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = Total.crime.Rate)) + 
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = NULL, y = NULL) + 
  coord_equal() +
  geom_polygon(data = CTTowns, colour = "grey", alpha = 0.5, fill = NA) +
  scale_fill_brewer(palette = "Purples", name = "Total crime rate\n(Crimes per 100K residents)") +
  theme_minimal(base_size = 16)

write.csv(totalcrime_avg,"slide17.csv",row.names = FALSE)
```

--- 
## Voter turnout another measure of civic health

With with housing, crime. Add in factoid about diversity of gov't officials representing electorate (Hartford / region are among the worst nationally).

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 14}
voting <- read.csv('2012-voting.csv')
#voting$Town <- gsub(pattern = " (CD1&2)", replacement = "", voting$Town)
voting <- subset(voting, voting$Town %in% levels(towns$Town))

voting$Town <- reorder(voting$Town, voting$Percentage.Checked.as.Having.Voted)

library(classInt)
jenks <- classIntervals(voting$Percentage.Checked.as.Having.Voted, 
                        n=3, style="fisher")
choropleth=merge(CTTowns, voting, by.x = "id", by.y="Town")
choropleth=choropleth[order(choropleth$order), ]
choropleth$Percentage.Checked.as.Having.Voted=
  cut(choropleth$Percentage.Checked.as.Having.Voted, 
                          breaks=jenks$brks,
                          include.lowest=T, dig.lab = T)
#Make the map
ggplot(data = choropleth, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = Percentage.Checked.as.Having.Voted)) + 
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = NULL, y = NULL) + 
  coord_equal() +
  geom_polygon(data = CTTowns, colour = "grey", alpha = 0.5, fill = NA) +
  scale_fill_brewer(palette = "Purples", name = "% registered voters\nthat voted") +
  theme_minimal(base_size = 16)

write.csv(voting,"slide18.csv",row.names = FALSE)
```

